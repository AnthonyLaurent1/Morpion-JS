
================================================================================
File: front\game.html
Size: 3.19 kB
================================================================================

<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Morpion 4 Joueurs</title>
  <link rel="stylesheet" href="./style/game.css">
</head>
<body>
  <main class="container">
    <div class="header">
      <h1>Morpion 4 Joueurs</h1>
      <div class="wave-info">
        <p>Vague: <strong id="waveNumber">1</strong></p>
        <p>Temps restant: <strong id="waveTimer">60</strong>s</p>
      </div>
    </div>

    <div class="game-content">
      <!-- Barre lat√©rale gauche: joueurs -->
      <aside class="players-sidebar">
        <h2>Joueurs</h2>
        <div id="playersList" class="players-list"></div>
      </aside>

      <!-- Grille de jeu -->
      <div class="board-container">
        <div class="action-mode">
          <button id="placeModeBtn" class="mode-btn active">
            <span class="icon">‚ûï</span>
            Placer (1 PA)
            <span class="cooldown-indicator" id="placeCooldown"></span>
          </button>
          <button id="destroyModeBtn" class="mode-btn">
            <span class="icon">‚ùå</span>
            D√©truire (1 PA)
            <span class="cooldown-indicator" id="destroyCooldown"></span>
          </button>
          <button id="abilityModeBtn" class="mode-btn">
            <span class="icon">‚ö°</span>
            Pouvoir
            <span class="cooldown-indicator" id="abilityCooldown"></span>
          </button>
          <button id="skipTurnBtn" class="mode-btn skip-btn">
            <span class="icon">‚è≠Ô∏è</span>
            Passer son tour
          </button>
        </div>

        <div class="board-wrapper">
          <div id="board" class="board"></div>
        </div>

        <div class="status-bar">
          <p id="statusMessage">En attente...</p>
          <p id="actionPointsDisplay" class="action-points">PA: 0</p>
        </div>
      </div>

      <!-- Barre lat√©rale droite: infos -->
      <aside class="info-sidebar">
        <h2>Votre classe</h2>
        <div id="classInfo" class="class-info"></div>

        <h2>Instructions</h2>
        <div class="instructions">
          <p><strong>But:</strong> Alignez 3 blocs de votre couleur</p>
          <p><strong>Actions de base:</strong></p>
          <ul>
            <li>Placer un bloc (2.5s CD)</li>
            <li>D√©truire un bloc (2.5s CD)</li>
          </ul>
          <p><strong>Astuce:</strong> Utilisez votre pouvoir sp√©cial strat√©giquement!</p>
        </div>
      </aside>
    </div>
  </main>

  <div id="gameOverModal" class="modal hidden">
    <div class="modal-content">
      <h2 id="gameOverTitle">Partie termin√©e</h2>
      <p id="gameOverMessage"></p>
      <div id="winnerInfo"></div>
      <button id="backToMenuBtn" class="btn-primary">Retour au menu</button>
    </div>
  </div>

  <div id="waveOverlay" class="wave-overlay hidden">
    <h1 id="waveOverlayText">Vague 1</h1>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.6.1/socket.io.min.js"></script>
  <script src="./js/game.js"></script>
</body>
</html>

================================================================================
File: front\index.html
Size: 3.28 kB
================================================================================

<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Morpion 4 Joueurs - Accueil</title>
    <link rel="stylesheet" href="./style/home.css">
</head>
<body>
  <main class="container">
    <h1>Morpion 4 Joueurs</h1>
    <p class="subtitle">Choisissez votre classe et rejoignez une partie</p>
    
    <div class="menu">
      <div class="input-group">
        <label for="pseudo">Votre pseudo (optionnel)</label>
        <input type="text" id="pseudo" placeholder="Laisser vide pour un pseudo al√©atoire" maxlength="20">
      </div>

      <div class="input-group">
        <label for="gameId">Code de partie (optionnel)</label>
        <input type="text" id="gameId" placeholder="Laisser vide pour cr√©er une nouvelle partie">
      </div>

      <div class="class-selection">
        <h2>Choisissez votre classe</h2>
        <div class="classes-grid">
          <div class="class-card" data-class="bombman">
            <div class="class-icon">üí£</div>
            <h3>Bombman</h3>
            <p>D√©truit en croix</p>
            <span class="cooldown">CD: 10s</span>
          </div>

          <div class="class-card" data-class="parieur">
            <div class="class-icon">üé≤</div>
            <h3>Le Parieur</h3>
            <p>D√©truit 3x3, remplace par 6 blocs al√©atoires</p>
            <span class="cooldown">CD: 10s</span>
          </div>

          <div class="class-card" data-class="bombwoman">
            <div class="class-icon">üí•</div>
            <h3>Bombwoman</h3>
            <p>D√©truit ligne/colonne, bloque 6s</p>
            <span class="cooldown">CD: 10s</span>
          </div>

          <div class="class-card" data-class="fast">
            <div class="class-icon">‚ö°</div>
            <h3>Le Fast</h3>
            <p>Blocs √† 0 PV, cooldown √∑2</p>
            <span class="cooldown">Passif</span>
          </div>

          <div class="class-card" data-class="solide">
            <div class="class-icon">üõ°Ô∏è</div>
            <h3>Le Solide</h3>
            <p>Blocs 2 PV, cooldown x2</p>
            <span class="cooldown">Passif</span>
          </div>

          <div class="class-card" data-class="roulette">
            <div class="class-icon">üé∞</div>
            <h3>La Roulette</h3>
            <p>Pose 2 blocs al√©atoires sur une ligne</p>
            <span class="cooldown">CD: 10s</span>
          </div>

          <div class="class-card" data-class="shuffle">
            <div class="class-icon">üîÄ</div>
            <h3>Le Shuffle</h3>
            <p>M√©lange toute la grille</p>
            <span class="cooldown">CD: 15s</span>
          </div>

          <div class="class-card" data-class="aleatoire">
            <div class="class-icon">üé≤</div>
            <h3>L'Al√©atoire</h3>
            <p>Pouvoir al√©atoire</p>
            <span class="cooldown">3 vagues</span>
          </div>
        </div>
      </div>

      <button id="joinBtn" class="join-btn" disabled>Rejoindre la partie</button>
      <p class="error-msg" id="errorMsg"></p>
    </div>
  </main>

  <script src="./js/home.js"></script>
</body>
</html>

================================================================================
File: front\js\game.js
Size: 15.52 kB
================================================================================

// Configuration
const SERVER_URL = window.location.origin;

// V√©rifier si le joueur vient de la salle d'attente
const gameStarted = sessionStorage.getItem('gameStarted');
const playerClass = sessionStorage.getItem('playerClass');

if (!gameStarted || !playerClass) {
  window.location.href = './index.html';
}

// Connexion Socket.IO avec reconnexion imm√©diate
const socket = io(SERVER_URL, {
  reconnection: true,
  reconnectionAttempts: 10,
  reconnectionDelay: 100, // Reconnexion tr√®s rapide (100ms)
  reconnectionDelayMax: 500,
  timeout: 10000,
  transports: ['websocket', 'polling']
});

// Gestion des erreurs de connexion
socket.on('connect_error', (error) => {
  console.error('Erreur de connexion:', error);
});

socket.on('join_error', (data) => {
  console.error('Erreur de connexion √† la partie:', data.message);
  alert(`Erreur: ${data.message}`);
  window.location.href = './index.html';
});

const gameId = sessionStorage.getItem('gameId');
const oldSocketId = sessionStorage.getItem('socketId');
const playerPseudo = sessionStorage.getItem('playerPseudo') || '';

socket.on('connect', () => {
  console.log('‚úÖ Connexion √©tablie avec nouveau socket:', socket.id);
  console.log('üìù Ancien socket:', oldSocketId);
  console.log('üéÆ Tentative de reconnexion √† la partie:', gameId, 'avec la classe:', playerClass);
  
  socket.emit('join_game', {
    gameId: gameId ? parseInt(gameId) : null,
    playerClass: playerClass,
    pseudo: playerPseudo
  });
});

// Confirmation de reconnexion
socket.on('join_success', (data) => {
  console.log('‚úÖ Reconnexion r√©ussie!', data);
  if (data.reconnected) {
    console.log('üîÑ Reconnexion d√©tect√©e par le serveur');
  }
});

// √âl√©ments DOM
const boardEl = document.getElementById('board');
const waveNumberEl = document.getElementById('waveNumber');
const waveTimerEl = document.getElementById('waveTimer');
const playersListEl = document.getElementById('playersList');
const classInfoEl = document.getElementById('classInfo');
const statusMessageEl = document.getElementById('statusMessage');

const placeModeBtn = document.getElementById('placeModeBtn');
const destroyModeBtn = document.getElementById('destroyModeBtn');
const abilityModeBtn = document.getElementById('abilityModeBtn');
const skipTurnBtn = document.getElementById('skipTurnBtn');

const placeCooldownEl = document.getElementById('placeCooldown');
const destroyCooldownEl = document.getElementById('destroyCooldown');
const abilityCooldownEl = document.getElementById('abilityCooldown');
const actionPointsDisplay = document.getElementById('actionPointsDisplay');

const waveOverlay = document.getElementById('waveOverlay');
const waveOverlayText = document.getElementById('waveOverlayText');

const gameOverModal = document.getElementById('gameOverModal');
const gameOverTitle = document.getElementById('gameOverTitle');
const gameOverMessage = document.getElementById('gameOverMessage');
const winnerInfoEl = document.getElementById('winnerInfo');
const backToMenuBtn = document.getElementById('backToMenuBtn');

// √âtat local
let myPlayerId = null;
let myColor = null;
let currentMode = 'place'; // 'place', 'destroy', 'ability'
let gameState = null;
let waveEndTime = null;
let timerInterval = null;

// Informations des classes
const classInfo = {
  'bombman': {
    icon: 'üí£',
    name: 'Bombman',
    description: 'D√©truit en croix autour de lui',
    cooldown: '10s'
  },
  'parieur': {
    icon: 'üé≤',
    name: 'Le Parieur',
    description: 'D√©truit une zone 3x3 et remplace par 6 blocs al√©atoires',
    cooldown: '10s'
  },
  'bombwoman': {
    icon: 'üí•',
    name: 'Bombwoman',
    description: 'D√©truit une ligne ou colonne enti√®re',
    cooldown: '10s'
  },
  'fast': {
    icon: '‚ö°',
    name: 'Le Fast',
    description: 'Blocs √† 0 PV, cooldowns divis√©s par 2',
    cooldown: 'Passif'
  },
  'solide': {
    icon: 'üõ°Ô∏è',
    name: 'Le Solide',
    description: 'Blocs avec 2 PV',
    cooldown: 'Passif'
  },
  'roulette': {
    icon: 'üé∞',
    name: 'La Roulette',
    description: 'Pose 2 blocs al√©atoires sur une ligne',
    cooldown: '10s'
  },
  'shuffle': {
    icon: 'üîÄ',
    name: 'Le Shuffle',
    description: 'M√©lange al√©atoirement toute la grille',
    cooldown: '15s'
  },
  'aleatoire': {
    icon: 'üé≤',
    name: 'L\'Al√©atoire',
    description: 'Pouvoir al√©atoire qui change √† chaque utilisation',
    cooldown: '3 vagues'
  }
};

// Initialisation
function init() {
  createBoard();
  displayClassInfo();
  setupModeButtons();
}

// Cr√©er la grille
function createBoard() {
  boardEl.innerHTML = '';
  for (let i = 0; i < 25; i++) {
    const cell = document.createElement('div');
    cell.className = 'cell';
    cell.dataset.row = Math.floor(i / 5);
    cell.dataset.col = i % 5;
    cell.addEventListener('click', handleCellClick);
    boardEl.appendChild(cell);
  }
}

// Afficher les informations de classe
function displayClassInfo() {
  const info = classInfo[playerClass];
  classInfoEl.innerHTML = `
    <div class="icon">${info.icon}</div>
    <h3>${info.name}</h3>
    <p>${info.description}</p>
    <p style="margin-top: 10px; color: var(--primary);">CD: ${info.cooldown}</p>
  `;
}

// Configuration des boutons de mode
function setupModeButtons() {
  placeModeBtn.addEventListener('click', () => {
    currentMode = 'place';
    updateModeButtons();
  });

  destroyModeBtn.addEventListener('click', () => {
    currentMode = 'destroy';
    updateModeButtons();
  });

  abilityModeBtn.addEventListener('click', () => {
    currentMode = 'ability';
    updateModeButtons();
  });

  skipTurnBtn.addEventListener('click', () => {
    socket.emit('skip_turn');
    showNotification('Tour pass\u00e9 ! PA conserv\u00e9s pour la prochaine vague.');
  });
}

// Changer de mode
function setMode(mode) {
  currentMode = mode;
  
  placeModeBtn.classList.toggle('active', mode === 'place');
  destroyModeBtn.classList.toggle('active', mode === 'destroy');
  abilityModeBtn.classList.toggle('active', mode === 'ability');
}

// Gestion du clic sur une cellule
function handleCellClick(e) {
  const cell = e.target;
  const row = parseInt(cell.dataset.row);
  const col = parseInt(cell.dataset.col);
  
  if (!gameState || !gameState.started) return;

  switch (currentMode) {
    case 'place':
      socket.emit('place_block', { x: row, y: col });
      break;
    case 'destroy':
      socket.emit('destroy_block', { x: row, y: col });
      break;
    case 'ability':
      socket.emit('use_ability', { x: row, y: col });
      showAbilityAnimation(playerClass);
      break;
  }
}

function showAbilityAnimation(className) {
  const passiveClasses = ['fast', 'solide'];
  if (passiveClasses.includes(className)) return;
  
  const overlay = document.createElement('div');
  overlay.className = 'ability-animation';
  
  const icons = {
    'bombman': 'üí£',
    'bombwoman': 'üí•',
    'parieur': 'üé≤',
    'roulette': 'üé∞',
    'shuffle': 'üîÄ',
    'aleatoire': 'üé≤'
  };
  
  overlay.textContent = icons[className] || '‚ö°';
  document.body.appendChild(overlay);
  
  setTimeout(() => overlay.classList.add('show'), 10);
  setTimeout(() => {
    overlay.classList.remove('show');
    setTimeout(() => overlay.remove(), 300);
  }, 800);
}

function showNotification(message) {
  const notif = document.createElement('div');
  notif.className = 'notification';
  notif.textContent = message;
  document.body.appendChild(notif);
  
  setTimeout(() => notif.classList.add('show'), 10);
  setTimeout(() => {
    notif.classList.remove('show');
    setTimeout(() => notif.remove(), 300);
  }, 2000);
}

function updateBoard(grid) {
  const cells = boardEl.querySelectorAll('.cell');
  
  grid.forEach((row, rowIndex) => {
    row.forEach((cell, colIndex) => {
      const cellIndex = rowIndex * 5 + colIndex;
      const cellEl = cells[cellIndex];
      
      const wasOccupied = cellEl.classList.contains('occupied');
      const previousColor = cellEl.style.backgroundColor;
      
      cellEl.className = 'cell';
      cellEl.style.backgroundColor = '';
      cellEl.textContent = '';
      
      if (cell.color) {
        cellEl.style.backgroundColor = cell.color;
        cellEl.classList.add('occupied');
        
        if (cell.hp > 1) {
          cellEl.classList.add('hp-2');
        }
        
        if (cell.waveNumber === gameState.waveNumber) {
          cellEl.classList.add('protected');
          const shield = document.createElement('span');
          shield.className = 'shield-icon';
          shield.textContent = 'üõ°Ô∏è';
          cellEl.appendChild(shield);
        }
      } else if (wasOccupied && previousColor && previousColor !== cell.color) {
        cellEl.classList.add('destroyed');
        setTimeout(() => cellEl.classList.remove('destroyed'), 500);
      }
    });
  });
}

function updatePlayersList(players) {
  playersListEl.innerHTML = '';
  
  players.forEach(player => {
    const isMe = player.id === myPlayerId;
    
    const item = document.createElement('div');
    item.className = 'player-item' + (isMe ? ' active' : '');
    
    const colorDiv = document.createElement('div');
    colorDiv.className = 'player-color-indicator';
    colorDiv.style.backgroundColor = player.color;
    
    const detailsDiv = document.createElement('div');
    detailsDiv.className = 'player-details';
    
    const nameP = document.createElement('p');
    nameP.textContent = isMe ? `Vous (${player.pseudo})` : player.pseudo;
    
    const classP = document.createElement('p');
    classP.className = 'player-class';
    classP.textContent = classInfo[player.class].name;
    
    const paP = document.createElement('p');
    paP.className = 'player-pa';
    if (player.hasSkipped) {
      paP.textContent = 'A pass√© son tour';
      paP.style.fontStyle = 'italic';
      paP.style.color = 'var(--text-dim)';
    } else {
      paP.textContent = `PA: ${player.actionPoints}`;
    }
    
    const abilityP = document.createElement('p');
    abilityP.className = 'player-ability';
    abilityP.textContent = `Pouvoir: ${player.abilityCharges}/3`;
    
    detailsDiv.appendChild(nameP);
    detailsDiv.appendChild(classP);
    detailsDiv.appendChild(paP);
    detailsDiv.appendChild(abilityP);
    
    item.appendChild(colorDiv);
    item.appendChild(detailsDiv);
    
    playersListEl.appendChild(item);
  });
}

function updateCooldowns(player) {
  const myPlayer = gameState.players.find(p => p.id === myPlayerId);
  if (!myPlayer) return;
  
  const passiveClasses = ['fast', 'solide'];
  const hasPassiveClass = passiveClasses.includes(myPlayer.class);
  
  placeModeBtn.disabled = !myPlayer.canPlace;
  destroyModeBtn.disabled = !myPlayer.canDestroy;
  abilityModeBtn.disabled = !myPlayer.canUseAbility;
  skipTurnBtn.disabled = myPlayer.actionPoints === 0;
  
  if (hasPassiveClass) {
    abilityModeBtn.style.display = 'none';
  } else {
    abilityModeBtn.style.display = 'flex';
  }
  
  placeCooldownEl.textContent = myPlayer.canPlace ? 'OK' : 'X';
  destroyCooldownEl.textContent = myPlayer.canDestroy ? 'OK' : 'X';
  abilityCooldownEl.textContent = myPlayer.canUseAbility ? 'OK' : `${myPlayer.abilityCharges}/3`;
  
  actionPointsDisplay.textContent = `PA: ${myPlayer.actionPoints}`;
  
  if (myPlayer.actionPoints > 0) {
    statusMessageEl.textContent = `A vous de jouer !`;
  } else {
    statusMessageEl.textContent = 'En attente des autres joueurs...';
  }
}

// D√©marrer le timer de vague
function startWaveTimer(duration) {
  waveEndTime = Date.now() + duration;
  
  if (timerInterval) clearInterval(timerInterval);
  
  timerInterval = setInterval(() => {
    const remaining = Math.max(0, Math.ceil((waveEndTime - Date.now()) / 1000));
    waveTimerEl.textContent = remaining;
    
    if (remaining === 0) {
      clearInterval(timerInterval);
    }
  }, 100);
}

// === √âV√âNEMENTS SOCKET ===

socket.on('join_success', (data) => {
  myPlayerId = data.playerId;
  myColor = data.playerColor;
  console.log('Reconnect√© au jeu');
});

socket.on('game_state_update', (state) => {
  gameState = state;
  
  if (state.grid) {
    updateBoard(state.grid);
  }
  
  if (state.players) {
    updatePlayersList(state.players);
    updateCooldowns();
  }
  
  if (state.waveNumber) {
    waveNumberEl.textContent = state.waveNumber;
  }
});

socket.on('wave_start', (data) => {
  waveNumberEl.textContent = data.waveNumber;
  startWaveTimer(data.duration);
  showWaveAnimation(data.waveNumber);
});

function showWaveAnimation(waveNumber) {
  waveOverlayText.textContent = `Vague ${waveNumber}`;
  waveOverlay.classList.remove('hidden');
  waveOverlay.classList.add('show');
  
  setTimeout(() => {
    waveOverlay.classList.remove('show');
    setTimeout(() => {
      waveOverlay.classList.add('hidden');
    }, 300);
  }, 1000);
}

socket.on('wave_end', (data) => {
  statusMessageEl.textContent = `Vague ${data.waveNumber} termin√©e !`;
});

socket.on('time_stop_start', (data) => {
  if (data.voyageurId !== myPlayerId) {
    statusMessageEl.textContent = '‚è∞ LE TEMPS EST ARR√äT√â !';
    statusMessageEl.style.color = 'var(--warning)';
  } else {
    statusMessageEl.textContent = '‚è∞ Vous contr√¥lez le temps !';
    statusMessageEl.style.color = 'var(--success)';
  }
});

socket.on('time_stop_end', (data) => {
  statusMessageEl.textContent = 'Le temps reprend son cours';
  statusMessageEl.style.color = 'var(--text)';
});

socket.on('game_over', (data) => {
  if (timerInterval) clearInterval(timerInterval);
  
  showGameOver(data);
});

socket.on('player_left', (data) => {
  statusMessageEl.textContent = 'Un joueur a quitt√© la partie';
});

// Afficher l'√©cran de fin de partie
function showGameOver(data) {
  gameOverModal.classList.remove('hidden');
  
  if (data.winner) {
    gameOverTitle.textContent = data.winner.id === myPlayerId ? 'üéâ VICTOIRE !' : 'üò¢ D√©faite';
    gameOverMessage.textContent = data.winner.id === myPlayerId 
      ? 'F√©licitations ! Vous avez gagn√© !' 
      : 'Dommage ! Un autre joueur a gagn√©.';
    
    const info = classInfo[data.winner.class];
    winnerInfoEl.innerHTML = `
      <div class="winner-display">
        <div class="winner-color" style="background-color: ${data.winner.color}"></div>
        <div class="winner-details">
          <h3>${info.icon} ${info.name}</h3>
          <p>${data.winner.id === myPlayerId ? 'Vous' : 'Adversaire'}</p>
        </div>
      </div>
    `;
  } else {
    gameOverTitle.textContent = 'Partie termin√©e';
    gameOverMessage.textContent = data.reason === 'not_enough_players' 
      ? 'Pas assez de joueurs pour continuer' 
      : 'La partie est termin√©e';
    winnerInfoEl.innerHTML = '';
  }
}

// Retour au menu
backToMenuBtn.addEventListener('click', () => {
  socket.disconnect();
  sessionStorage.clear();
  window.location.href = './index.html';
});

// Gestion de la fermeture de la page
window.addEventListener('beforeunload', () => {
  socket.disconnect();
});

// Initialiser
init();

================================================================================
File: front\js\home.js
Size: 1.76 kB
================================================================================

// Configuration
const SERVER_URL = window.location.origin;

const pseudoInput = document.getElementById('pseudo');
const gameIdInput = document.getElementById('gameId');
const joinBtn = document.getElementById('joinBtn');
const errorMsg = document.getElementById('errorMsg');
const classCards = document.querySelectorAll('.class-card');

// √âtat
let selectedClass = null;

// Initialisation
classCards.forEach(card => {
  card.addEventListener('click', () => {
    // Retirer la s√©lection pr√©c√©dente
    classCards.forEach(c => c.classList.remove('selected'));
    
    // S√©lectionner la nouvelle classe
    card.classList.add('selected');
    selectedClass = card.dataset.class;
    
    // Activer le bouton
    joinBtn.disabled = false;
    errorMsg.textContent = '';
  });
});

joinBtn.addEventListener('click', () => {
  if (!selectedClass) {
    showError('Veuillez s√©lectionner une classe');
    return;
  }

  const pseudo = pseudoInput.value.trim();
  const gameId = gameIdInput.value.trim();

  sessionStorage.setItem('playerClass', selectedClass);
  if (pseudo) {
    sessionStorage.setItem('playerPseudo', pseudo);
  } else {
    sessionStorage.removeItem('playerPseudo');
  }
  if (gameId) {
    sessionStorage.setItem('gameId', gameId);
  } else {
    sessionStorage.removeItem('gameId');
  }

  window.location.href = './waiting.html';
});

// Afficher une erreur
function showError(message) {
  errorMsg.textContent = message;
  setTimeout(() => {
    errorMsg.textContent = '';
  }, 3000);
}

// Permettre d'appuyer sur Entr√©e pour rejoindre
gameIdInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter' && !joinBtn.disabled) {
    joinBtn.click();
  }
});

================================================================================
File: front\js\waiting.js
Size: 5.47 kB
================================================================================

// Configuration
// Socket.IO utilise http/https, pas ws/wss
const SERVER_URL = window.location.origin;

const playerClass = sessionStorage.getItem('playerClass');
const gameId = sessionStorage.getItem('gameId');
const playerPseudo = sessionStorage.getItem('playerPseudo') || '';

if (!playerClass) {
  window.location.href = './index.html';
}

// Configuration de la connexion Socket.IO
const socket = io(SERVER_URL, {
  reconnection: true,
  reconnectionAttempts: 5,
  reconnectionDelay: 1000,
  timeout: 20000,
  transports: ['websocket', 'polling']
});

// Gestion des erreurs de connexion
socket.on('connect_error', (error) => {
  console.error('Erreur de connexion:', error);
  alert(`Impossible de se connecter au serveur: ${error.message}. V√©rifiez que le serveur est en cours d'ex√©cution et que vous √™tes connect√© au bon r√©seau.`);
  window.location.href = './index.html';
});

socket.on('connect_timeout', () => {
  console.error('D√©lai de connexion d√©pass√©');
  alert('Le serveur ne r√©pond pas. V√©rifiez votre connexion r√©seau.');
});

// √âl√©ments DOM
const gameCodeEl = document.getElementById('gameCode');
const playerCountEl = document.getElementById('playerCount');
const playersListEl = document.getElementById('playersList');
const leaveBtn = document.getElementById('leaveBtn');
const startGameBtn = document.getElementById('startGameBtn');

// √âtat local
let currentGameId = null;
let myPlayerId = null;

// Classes avec leurs ic√¥nes
const classIcons = {
  'bombman': 'üí£',
  'parieur': 'üé≤',
  'bombwoman': 'üí•',
  'fast': '‚ö°',
  'solide': 'üõ°Ô∏è',
  'roulette': 'üé∞',
  'shuffle': 'üîÄ',
  'voyageur': '‚è∞'
};

const classNames = {
  'bombman': 'Bombman',
  'parieur': 'Le Parieur',
  'bombwoman': 'Bombwoman',
  'fast': 'Le Fast',
  'solide': 'Le Solide',
  'roulette': 'La Roulette',
  'shuffle': 'Le Shuffle',
  'voyageur': 'Le Voyageur'
};

socket.emit('join_game', {
  gameId: gameId ? parseInt(gameId) : null,
  playerClass: playerClass,
  pseudo: playerPseudo
});

// Succ√®s de la connexion
socket.on('join_success', (data) => {
  currentGameId = data.gameId;
  myPlayerId = data.playerId;
  
  // Stocker le gameId dans sessionStorage pour la reconnexion
  sessionStorage.setItem('gameId', data.gameId);
  
  gameCodeEl.textContent = data.gameId;
  
  console.log('Connexion r√©ussie:', data);
});

// Erreur de connexion
socket.on('join_error', (data) => {
  alert(data.message);
  window.location.href = './index.html';
});

// Mise √† jour de l'√©tat du jeu
socket.on('game_state_update', (state) => {
  updatePlayersList(state.players);
  // Activer le bouton d√©marrer si min 2 joueurs et partie pas commenc√©e
  if (startGameBtn) {
    startGameBtn.disabled = !(state.players.length >= 2 && !state.started);
  }
});

// Partie d√©marr√©e
socket.on('game_started', (data) => {
  console.log('La partie commence!');
  
  // Stocker les informations de la partie
  sessionStorage.setItem('gameStarted', 'true');
  
  // IMPORTANT: Ne pas d√©connecter le socket, il sera r√©utilis√© dans game.html
  // On stocke l'ID du socket pour debug
  sessionStorage.setItem('socketId', socket.id);
  console.log('Redirection vers game.html avec socket:', socket.id);
  
  // Rediriger vers la page de jeu
  window.location.href = './game.html';
});

// Joueur parti
socket.on('player_left', (data) => {
  console.log('Joueur parti:', data.playerId);
});

// D√©marrer la partie manuellement
if (startGameBtn) {
  startGameBtn.addEventListener('click', () => {
    socket.emit('start_game');
  });
}

socket.on('start_error', (data) => {
  alert(data.message || 'Impossible de d√©marrer la partie');
});

// Mise √† jour de la liste des joueurs
function updatePlayersList(players) {
  playerCountEl.textContent = players.length;
  
  playersListEl.innerHTML = '';
  
  players.forEach(player => {
    const isMe = player.id === myPlayerId;
    
    const card = document.createElement('div');
    card.className = 'player-card' + (isMe ? ' you' : '');
    
    const colorDiv = document.createElement('div');
    colorDiv.className = 'player-color';
    colorDiv.style.backgroundColor = player.color;
    
    const infoDiv = document.createElement('div');
    infoDiv.className = 'player-info';
    
    const nameP = document.createElement('p');
    nameP.className = 'player-name';
    nameP.textContent = isMe ? `Vous (${player.pseudo})` : player.pseudo;
    
    const classP = document.createElement('p');
    classP.className = 'player-class';
    classP.textContent = `${classIcons[player.class]} ${classNames[player.class]}`;
    
    infoDiv.appendChild(nameP);
    infoDiv.appendChild(classP);
    
    card.appendChild(colorDiv);
    card.appendChild(infoDiv);
    
    if (isMe) {
      const badge = document.createElement('span');
      badge.className = 'player-badge';
      badge.textContent = 'VOUS';
      card.appendChild(badge);
    }
    
    playersListEl.appendChild(card);
  });
}

// Quitter la partie
leaveBtn.addEventListener('click', () => {
  socket.disconnect();
  sessionStorage.clear();
  window.location.href = './index.html';
});

// Gestion de la fermeture de la page
window.addEventListener('beforeunload', () => {
  if (!sessionStorage.getItem('gameStarted')) {
    socket.disconnect();
  }
});

================================================================================
File: front\style\game.css
Size: 10.27 kB
================================================================================

:root {
  --primary: #4f46e5;
  --primary-dark: #4338ca;
  --bg: #0f172a;
  --bg-light: #1e293b;
  --text: #f1f5f9;
  --text-dim: #94a3b8;
  --accent: #8b5cf6;
  --success: #10b981;
  --error: #ef4444;
  --warning: #f59e0b;
  --border: #334155;
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html, body {
  height: 100%;
  font-family: 'Segoe UI', system-ui, sans-serif;
  background: linear-gradient(135deg, var(--bg) 0%, #1a1f3a 100%);
  color: var(--text);
  overflow-x: hidden;
}

body {
  padding: 20px;
}

.container {
  max-width: 1400px;
  margin: 0 auto;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  padding: 20px;
  background: var(--bg-light);
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

h1 {
  font-size: 2rem;
  background: linear-gradient(135deg, var(--primary), var(--accent));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.wave-info {
  display: flex;
  gap: 20px;
  font-size: 1rem;
}

.wave-info p {
  color: var(--text-dim);
}

.wave-info strong {
  color: var(--text);
  font-size: 1.2rem;
}

.game-content {
  display: grid;
  grid-template-columns: 250px 1fr 280px;
  gap: 20px;
}

/* Sidebars */
.players-sidebar,
.info-sidebar {
  background: var(--bg-light);
  border-radius: 12px;
  padding: 20px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.players-sidebar h2,
.info-sidebar h2 {
  font-size: 1.1rem;
  margin-bottom: 15px;
  color: var(--primary);
}

.players-list {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.player-item {
  background: var(--bg);
  border: 2px solid var(--border);
  border-radius: 8px;
  padding: 12px;
  display: flex;
  align-items: center;
  gap: 10px;
}

.player-item.active {
  border-color: var(--success);
  box-shadow: 0 0 15px rgba(16, 185, 129, 0.3);
}

.player-color-indicator {
  width: 30px;
  height: 30px;
  border-radius: 50%;
  border: 2px solid rgba(255, 255, 255, 0.3);
  flex-shrink: 0;
}

.player-details {
  flex: 1;
  overflow: hidden;
}

.player-name {
  font-size: 1rem;
  font-weight: 600;
  color: var(--text);
  margin-bottom: 2px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
}

.player-class {
  font-size: 0.85rem;
  color: var(--text-dim);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.class-info {
  background: var(--bg);
  border-radius: 8px;
  padding: 15px;
  margin-bottom: 20px;
}

.class-info .icon {
  font-size: 2.5rem;
  margin-bottom: 10px;
}

.class-info h3 {
  margin-bottom: 8px;
}

.class-info p {
  color: var(--text-dim);
  font-size: 0.9rem;
}

.instructions {
  background: var(--bg);
  border-radius: 8px;
  padding: 15px;
}

.instructions p {
  margin-bottom: 10px;
  color: var(--text-dim);
  font-size: 0.9rem;
}

.instructions ul {
  list-style: none;
  padding-left: 0;
}

.instructions li {
  padding: 6px 0;
  color: var(--text-dim);
  font-size: 0.85rem;
}

.instructions li:before {
  content: "‚Üí ";
  color: var(--primary);
  font-weight: bold;
}

/* Board container */
.board-container {
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.action-mode {
  display: flex;
  gap: 10px;
  justify-content: center;
}

.mode-btn {
  flex: 1;
  max-width: 200px;
  padding: 12px 20px;
  background: var(--bg-light);
  border: 2px solid var(--border);
  border-radius: 12px;
  color: var(--text);
  font-size: 0.95rem;
  font-weight: 600;
  cursor: pointer;
  transition: 0.2s;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 5px;
  position: relative;
}

.mode-btn .icon {
  font-size: 1.5rem;
}

.mode-btn:hover:not(:disabled) {
  border-color: var(--primary);
  transform: translateY(-2px);
}

.mode-btn.active {
  background: linear-gradient(135deg, rgba(79, 70, 229, 0.3), rgba(139, 92, 246, 0.2));
  border-color: var(--primary);
  box-shadow: 0 0 20px rgba(79, 70, 229, 0.4);
}

.mode-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.cooldown-indicator {
  font-size: 0.75rem;
  color: var(--warning);
  min-height: 16px;
}

.board-wrapper {
  background: var(--bg-light);
  border-radius: 12px;
  padding: 20px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.board {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 8px;
  max-width: 500px;
  margin: 0 auto;
}

.cell {
  aspect-ratio: 1;
  background: var(--bg);
  border: 3px solid var(--border);
  border-radius: 12px;
  cursor: pointer;
  transition: 0.15s;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.2rem;
  font-weight: 800;
}

.cell:hover:not(.occupied):not(.disabled) {
  border-color: var(--primary);
  transform: scale(1.05);
  box-shadow: 0 4px 12px rgba(79, 70, 229, 0.4);
}

.cell.occupied {
  cursor: pointer;
}

.cell.disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.cell.hp-2:after {
  content: "2";
  position: absolute;
  top: 4px;
  right: 4px;
  font-size: 0.7rem;
  background: rgba(255, 255, 255, 0.3);
  padding: 2px 6px;
  border-radius: 50%;
}

.cell.winning {
  animation: winPulse 0.6s ease-in-out infinite;
  border-color: #fbbf24 !important;
  box-shadow: 0 0 25px rgba(251, 191, 36, 0.6);
}

@keyframes winPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.08); }
}

.status-bar {
  background: var(--bg-light);
  border-radius: 12px;
  padding: 15px;
  text-align: center;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

#statusMessage {
  font-size: 1rem;
  color: var(--text);
}

/* Modal */
.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.modal.hidden {
  display: none;
}

.modal-content {
  background: var(--bg-light);
  border-radius: 16px;
  padding: 40px;
  max-width: 500px;
  text-align: center;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
}

.modal-content h2 {
  font-size: 2rem;
  margin-bottom: 20px;
  background: linear-gradient(135deg, var(--primary), var(--accent));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.modal-content p {
  font-size: 1.1rem;
  color: var(--text-dim);
  margin-bottom: 20px;
}

#winnerInfo {
  margin: 20px 0;
}

.winner-display {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 15px;
  padding: 20px;
  background: var(--bg);
  border-radius: 12px;
  margin-bottom: 10px;
}

.winner-color {
  width: 60px;
  height: 60px;
  border-radius: 50%;
  border: 4px solid rgba(255, 255, 255, 0.3);
}

.winner-details h3 {
  font-size: 1.3rem;
  margin-bottom: 5px;
}

.btn-primary {
  width: 100%;
  padding: 14px;
  background: linear-gradient(135deg, var(--primary), var(--accent));
  color: white;
  border: none;
  border-radius: 12px;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: 0.2s;
}

.btn-primary:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 20px rgba(79, 70, 229, 0.4);
}

@media (max-width: 1200px) {
  .game-content {
    grid-template-columns: 1fr;
  }

  .players-sidebar,
  .info-sidebar {
    display: none;
  }
}

@media (max-width: 768px) {
  .header {
    flex-direction: column;
    gap: 15px;
  }

  .mode-btn {
    padding: 10px;
    font-size: 0.85rem;
  }

  .board {
    gap: 6px;
  }

  .cell {
    border-width: 2px;
  }
}

.wave-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.9);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 2000;
  opacity: 0;
  transition: opacity 0.3s ease;
}

.wave-overlay.show {
  opacity: 1;
}

.wave-overlay.hidden {
  display: none;
}

.wave-overlay h1 {
  font-size: 6rem;
  background: linear-gradient(135deg, var(--primary), var(--accent));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  animation: pulse 1s ease-in-out;
}

@keyframes pulse {
  0%, 100% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.1);
  }
}

.cell.protected {
  position: relative;
  box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
}

.shield-icon {
  position: absolute;
  top: 2px;
  right: 2px;
  font-size: 1.2rem;
  filter: drop-shadow(0 0 2px rgba(0, 0, 0, 0.8));
}

.action-points {
  font-size: 1.2rem;
  font-weight: bold;
  color: var(--primary);
}

.skip-btn {
  background: var(--warning);
}

.skip-btn:hover:not(:disabled) {
  background: #d97706;
}

.cell.destroyed {
  animation: destroyEffect 0.5s ease-out;
}

@keyframes destroyEffect {
  0% {
    transform: scale(1);
    opacity: 1;
  }
  50% {
    transform: scale(1.2);
    opacity: 0.5;
    box-shadow: 0 0 20px rgba(239, 68, 68, 0.8);
  }
  100% {
    transform: scale(0.8);
    opacity: 1;
  }
}

.ability-animation {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0);
  font-size: 8rem;
  z-index: 3000;
  opacity: 0;
  transition: all 0.3s ease;
  pointer-events: none;
  filter: drop-shadow(0 0 20px rgba(79, 70, 229, 0.8));
}

.ability-animation.show {
  transform: translate(-50%, -50%) scale(1);
  opacity: 1;
}

.notification {
  position: fixed;
  top: 100px;
  right: 20px;
  background: var(--bg-light);
  color: var(--text);
  padding: 15px 25px;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  border-left: 4px solid var(--primary);
  z-index: 2500;
  opacity: 0;
  transform: translateX(400px);
  transition: all 0.3s ease;
  font-weight: 500;
}

.notification.show {
  opacity: 1;
  transform: translateX(0);
}

================================================================================
File: front\style\home.css
Size: 3.54 kB
================================================================================

:root {
  --primary: #4f46e5;
  --primary-dark: #4338ca;
  --bg: #0f172a;
  --bg-light: #1e293b;
  --text: #f1f5f9;
  --text-dim: #94a3b8;
  --accent: #8b5cf6;
  --success: #10b981;
  --error: #ef4444;
  --border: #334155;
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html, body {
  min-height: 100%;
  font-family: 'Segoe UI', system-ui, sans-serif;
  background: linear-gradient(135deg, var(--bg) 0%, #1a1f3a 100%);
  color: var(--text);
  margin: 0;
  padding: 20px;
  box-sizing: border-box;
}

.container {
  width: 100%;
  max-width: 900px;
  margin: 0 auto;
  text-align: center;
  padding: 20px 0;
}

h1 {
  font-size: 3rem;
  margin-bottom: 10px;
  background: linear-gradient(135deg, var(--primary), var(--accent));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.subtitle {
  color: var(--text-dim);
  font-size: 1.1rem;
  margin-bottom: 40px;
}

.menu {
  background: var(--bg-light);
  border-radius: 16px;
  padding: 30px;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
}

.input-group {
  margin-bottom: 30px;
}

.input-group label {
  display: block;
  margin-bottom: 8px;
  color: var(--text-dim);
  font-size: 0.9rem;
  text-align: left;
}

.input-group input {
  width: 100%;
  padding: 12px 16px;
  background: var(--bg);
  border: 2px solid var(--border);
  border-radius: 8px;
  color: var(--text);
  font-size: 1rem;
  transition: 0.2s;
}

.input-group input:focus {
  outline: none;
  border-color: var(--primary);
}

.class-selection h2 {
  margin-bottom: 20px;
  color: var(--text);
  font-size: 1.3rem;
}

.classes-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  gap: 15px;
  margin-bottom: 30px;
}

.class-card {
  background: var(--bg);
  border: 2px solid var(--border);
  border-radius: 12px;
  padding: 20px;
  cursor: pointer;
  transition: 0.2s;
  text-align: center;
}

.class-card:hover {
  transform: translateY(-4px);
  border-color: var(--primary);
  box-shadow: 0 8px 20px rgba(79, 70, 229, 0.3);
}

.class-card.selected {
  border-color: var(--primary);
  background: linear-gradient(135deg, rgba(79, 70, 229, 0.2), rgba(139, 92, 246, 0.1));
  box-shadow: 0 0 20px rgba(79, 70, 229, 0.4);
}

.class-icon {
  font-size: 2.5rem;
  margin-bottom: 10px;
}

.class-card h3 {
  font-size: 1rem;
  margin-bottom: 8px;
  color: var(--text);
}

.class-card p {
  font-size: 0.85rem;
  color: var(--text-dim);
  margin-bottom: 8px;
  min-height: 40px;
}

.cooldown {
  display: inline-block;
  padding: 4px 10px;
  background: var(--primary);
  color: white;
  border-radius: 12px;
  font-size: 0.75rem;
  font-weight: 600;
}

.join-btn {
  width: 100%;
  padding: 16px;
  background: linear-gradient(135deg, var(--primary), var(--accent));
  color: white;
  border: none;
  border-radius: 12px;
  font-size: 1.1rem;
  font-weight: 600;
  cursor: pointer;
  transition: 0.2s;
}

.join-btn:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: 0 8px 20px rgba(79, 70, 229, 0.4);
}

.join-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.error-msg {
  color: var(--error);
  margin-top: 15px;
  font-size: 0.9rem;
  min-height: 20px;
}

@media (max-width: 768px) {
  h1 {
    font-size: 2rem;
  }
  
  .classes-grid {
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  }
}

================================================================================
File: front\style\waiting.css
Size: 3.86 kB
================================================================================

:root {
  --primary: #4f46e5;
  --primary-dark: #4338ca;
  --bg: #0f172a;
  --bg-light: #1e293b;
  --text: #f1f5f9;
  --text-dim: #94a3b8;
  --accent: #8b5cf6;
  --success: #10b981;
  --error: #ef4444;
  --border: #334155;
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html, body {
  height: 100%;
  font-family: 'Segoe UI', system-ui, sans-serif;
  background: linear-gradient(135deg, var(--bg) 0%, #1a1f3a 100%);
  color: var(--text);
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.container {
  width: 100%;
  max-width: 600px;
  background: var(--bg-light);
  border-radius: 16px;
  padding: 40px;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
  text-align: center;
}

h1 {
  font-size: 2.5rem;
  margin-bottom: 30px;
  background: linear-gradient(135deg, var(--primary), var(--accent));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.game-info {
  background: var(--bg);
  border-radius: 12px;
  padding: 20px;
  margin-bottom: 30px;
}

.game-code {
  font-size: 1.1rem;
  margin-bottom: 10px;
  color: var(--text-dim);
}

.game-code strong {
  color: var(--primary);
  font-size: 1.5rem;
  font-weight: 700;
  display: inline-block;
  padding: 5px 15px;
  background: rgba(79, 70, 229, 0.1);
  border-radius: 8px;
  margin-left: 10px;
}

.player-count {
  font-size: 1.1rem;
  color: var(--text-dim);
}

.player-count strong {
  color: var(--success);
  font-size: 1.3rem;
}

.players-list {
  display: grid;
  gap: 12px;
  margin-bottom: 30px;
}

.player-card {
  background: var(--bg);
  border: 2px solid var(--border);
  border-radius: 12px;
  padding: 15px;
  display: flex;
  align-items: center;
  gap: 15px;
  transition: 0.2s;
}

.player-card.you {
  border-color: var(--primary);
  box-shadow: 0 0 20px rgba(79, 70, 229, 0.3);
}

.player-color {
  width: 50px;
  height: 50px;
  border-radius: 50%;
  border: 3px solid rgba(255, 255, 255, 0.2);
  flex-shrink: 0;
}

.player-info {
  flex: 1;
  text-align: left;
}

.player-name {
  font-size: 1.1rem;
  font-weight: 600;
  margin-bottom: 4px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 200px;
  color: var(--text);
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
}

.player-class {
  color: var(--text-dim);
  font-size: 0.9rem;
}

.player-badge {
  padding: 4px 10px;
  background: var(--primary);
  color: white;
  border-radius: 12px;
  font-size: 0.75rem;
  font-weight: 600;
}

.waiting-message {
  margin-bottom: 30px;
}

.spinner {
  width: 50px;
  height: 50px;
  border: 4px solid rgba(79, 70, 229, 0.2);
  border-top-color: var(--primary);
  border-radius: 50%;
  margin: 0 auto 20px;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.waiting-message p {
  font-size: 1.1rem;
  margin-bottom: 8px;
}

.subtitle {
  color: var(--text-dim);
  font-size: 0.9rem;
}

.leave-btn {
  width: 100%;
  padding: 14px;
  background: var(--error);
  color: white;
  border: none;
  border-radius: 12px;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: 0.2s;
}

.leave-btn:hover {
  background: #dc2626;
  transform: translateY(-2px);
}


.start-btn {
  width: 100%;
  padding: 14px;
  background: var(--success);
  color: white;
  border: none;
  border-radius: 12px;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: 0.2s;
  margin-bottom: 10px;
}

.start-btn:hover {
  background: #059669;
  transform: translateY(-2px);
}



@media (max-width: 768px) {
  .container {
    padding: 25px;
  }

  h1 {
    font-size: 2rem;
  }
}

================================================================================
File: front\waiting.html
Size: 1.23 kB
================================================================================

<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Salle d'attente</title>
  <link rel="stylesheet" href="./style/waiting.css">
</head>
<body>
  <main class="container">
    <h1>Salle d'attente</h1>
    
    <div class="game-info">
      <p class="game-code">Code de la partie: <strong id="gameCode">----</strong></p>
      <p class="player-count">Joueurs: <strong id="playerCount">0</strong>/4</p>
    </div>

    <div class="players-list" id="playersList">
      <!-- Les joueurs appara√Ætront ici -->
    </div>

    <div class="waiting-message">
      <div class="spinner"></div>
      <p>En attente de joueurs...</p>
      <p class="subtitle">Quand vous √™tes pr√™ts, cliquez sur "D√©marrer la partie" (min 2 joueurs)</p>
    </div>

    <div class="actions">
      <button id="startGameBtn" class="start-btn">D√©marrer la partie</button>
      <button id="leaveBtn" class="leave-btn">Quitter la partie</button>
    </div>
  </main>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.6.1/socket.io.min.js"></script>
  <script src="./js/waiting.js"></script>
</body>
</html>

================================================================================
File: README.md
Size: 2.26 kB
================================================================================

üéÆ Morpion Multiclass Edition


üìù Description

Bienvenue dans le Morpion, la version ultime du jeu classique !
Chaque joueur choisit une classe unique avec des pouvoirs sp√©ciaux. Formez votre strat√©gie, utilisez vos capacit√©s et soyez le premier √† dominer la grille !

üë• Comment jouer

Choisissez votre classe et entrez votre pseudo (optionnel).

Si vous laissez vide ‚Üí pseudo al√©atoire.

Entrez un code de partie pour rejoindre une partie existante ou laissez vide pour cr√©er une nouvelle partie.

Jouez √† tour de r√¥le jusqu‚Äô√† ce qu‚Äôun joueur gagne ou que la grille soit remplie.

üßô Classes et capacit√©s
Classe	Pouvoir	Cooldown / Effet
üí£ Bombman	D√©truit en croix	105s
üé≤ Le Parieur	D√©truit 3x3, remplace par 6 blocs al√©atoires	105s
üí£ Bombwoman	D√©truit ligne/colonne, bloque 6s	105s
‚ö° Le Fast	Tous les blocs passent √† 0 PV, cooldown r√©duit +2	Passif
üõ°Ô∏è Le Solide	Blocs √† 2 PV, cooldown x2	Passif
üé∞ La Roulette	Pose 2 blocs al√©atoires sur une ligne	10s
üîÄ Le Shuffle	M√©lange toute la grille	155s
üé≤ L'Al√©atoire	Pouvoir al√©atoire	3 vagues

üí° Les cooldowns (CD) indiquent le temps √† attendre avant de r√©utiliser le pouvoir.

üïπÔ∏è Fonctionnement du jeu

Grille de jeu : La grille est adapt√©e de 2 √† 4 joueurs et affiche chaque symbole distinct.

Tour par tour : Les joueurs jouent √† tour de r√¥le et peuvent utiliser leur pouvoir sp√©cial quand il est disponible.

Objectif : Aligner vos symboles ou utiliser vos capacit√©s pour contrer vos adversaires.

Fin de partie :

Un joueur aligne une ligne, colonne ou diagonale ‚Üí Victoire üèÜ


üöÄ Instructions

Ouvrez index.html dans un navigateur.

Choisissez votre classe et entrez votre pseudo.

Rejoignez ou cr√©ez une partie.

Jouez en utilisant vos pouvoirs sp√©ciaux strat√©giquement.

Cliquez sur Recommencer pour une nouvelle partie.

‚ú® Astuces strat√©giques

üí£ Bombman / Bombwoman ‚Üí id√©al pour bloquer plusieurs adversaires √† la fois.

üé≤ Le Parieur ‚Üí parfait pour un changement massif de la grille.

‚ö° Le Fast ‚Üí √† utiliser pour d√©s√©quilibrer les blocs rapidement.

üîÄ Le Shuffle ‚Üí retournez la grille √† votre avantage ou pour semer le chaos !


================================================================================
File: websocket\gameManager.js
Size: 7.1 kB
================================================================================

// ============================================================================
// gameManager.js
// Gestionnaire principal des parties
// ============================================================================

import Game from './models/Game.js';

export default class GameManager {
  constructor(io) {
    this.io = io;
    this.games = new Map(); // gameId -> Game
    this.socketToGame = new Map(); // socketId -> gameId
    this.disconnectTimers = new Map(); // socketId -> timeout
  }

  // G√©n√©rer un ID de partie unique
  generateGameId() {
    let id;
    do {
      id = Math.floor(Math.random() * 9000) + 1000;
    } while (this.games.has(id));
    return id;
  }

  // Rejoindre ou cr√©er une partie
  handleJoinGame(socket, gameId, playerClass, pseudo = '') {
    let game = null;

    if (gameId) {
      game = this.games.get(gameId);
      
      if (!game) {
        socket.emit('join_error', { message: 'Partie introuvable' });
        return;
      }

      const existingPlayer = game.players.find(p => p.className === playerClass);
      if (existingPlayer) {
        console.log(`Reconnexion d√©tect√©e pour ${socket.id} (anciennement ${existingPlayer.playerId})`);
        
        if (this.disconnectTimers.has(existingPlayer.playerId)) {
          clearTimeout(this.disconnectTimers.get(existingPlayer.playerId));
          this.disconnectTimers.delete(existingPlayer.playerId);
          console.log(`Timer de d√©connexion annul√© pour ${existingPlayer.playerId}`);
        }
        
        this.socketToGame.delete(existingPlayer.playerId);
        existingPlayer.playerId = socket.id;
        this.socketToGame.set(socket.id, game.gameId);
        socket.join(`game_${game.gameId}`);
        
        socket.emit('join_success', {
          gameId: game.gameId,
          playerId: socket.id,
          playerColor: existingPlayer.color,
          playerClass: playerClass,
          pseudo: existingPlayer.pseudo,
          reconnected: true
        });
        
        socket.emit('game_state_update', game.getGameState());
        return;
      }
      
      if (game.players.length >= 4) {
        socket.emit('join_error', { message: 'Partie pleine' });
        return;
      }

      if (game.players.some(p => p.className === playerClass)) {
        socket.emit('join_error', { message: 'Classe d√©j√† prise' });
        return;
      }

      if (game.started) {
        socket.emit('join_error', { message: 'Partie d√©j√† commenc√©e' });
        return;
      }
    } else {
      const newGameId = this.generateGameId();
      game = new Game(newGameId, this.io);
      this.games.set(newGameId, game);
      console.log(`Nouvelle partie cr√©√©e: ${newGameId}`);
    }

    const success = game.addPlayer(socket, playerClass, pseudo);
    if (success) {
      const player = game.getPlayer(socket.id);
      this.socketToGame.set(socket.id, game.gameId);
      socket.join(`game_${game.gameId}`);
      socket.emit('join_success', {
        gameId: game.gameId,
        playerId: socket.id,
        playerColor: player.color,
        playerClass: playerClass,
        pseudo: player.pseudo
      });

      this.io.to(`game_${game.gameId}`).emit('game_state_update', game.getGameState());
    } else {
      socket.emit('join_error', { message: 'Erreur lors de la connexion' });
    }
  }

  // D√©marrer la partie manuellement
  handleStartGame(socket) {
    const gameId = this.socketToGame.get(socket.id);
    if (!gameId) return;
    const game = this.games.get(gameId);
    if (!game) return;
    if (game.started) return;
    if (game.players.length < 2) {
      socket.emit('start_error', { message: 'Minimum 2 joueurs requis' });
      return;
    }
    game.startGame();
  }

  // Placer un bloc
  handlePlaceBlock(socket, x, y) {
    const gameId = this.socketToGame.get(socket.id);
    if (!gameId) return;

    const game = this.games.get(gameId);
    if (!game) return;

    game.placeBlock(socket.id, x, y);
  }

  // D√©truire un bloc
  handleDestroyBlock(socket, x, y) {
    const gameId = this.socketToGame.get(socket.id);
    if (!gameId) return;

    const game = this.games.get(gameId);
    if (!game) return;

    game.destroyBlock(socket.id, x, y);
  }

  // Utiliser le pouvoir sp√©cial
  handleUseAbility(socket, x, y) {
    const gameId = this.socketToGame.get(socket.id);
    if (!gameId) return;

    const game = this.games.get(gameId);
    if (!game) return;

    game.useAbility(socket.id, x, y);
  }

  handleSkipTurn(socket) {
    const gameId = this.socketToGame.get(socket.id);
    if (!gameId) return;

    const game = this.games.get(gameId);
    if (!game) return;

    game.skipTurn(socket.id);
  }

  // G√©rer la d√©connexion
  handleDisconnect(socket) {
    const gameId = this.socketToGame.get(socket.id);
    if (!gameId) return;

    const game = this.games.get(gameId);
    if (!game) return;

    // Si la partie a d√©marr√©, donner 15 secondes pour se reconnecter
    if (game.started) {
      console.log(`Joueur ${socket.id} d√©connect√©, attente de reconnexion (15s)...`);
      
      const timer = setTimeout(() => {
        // V√©rifier si le joueur ne s'est toujours pas reconnect√©
        const currentGame = this.games.get(gameId);
        if (!currentGame) {
          this.disconnectTimers.delete(socket.id);
          this.socketToGame.delete(socket.id);
          return;
        }
        
        // V√©rifier si le joueur existe toujours avec cet ancien socket ID
        const player = currentGame.players.find(p => p.playerId === socket.id);
        if (player) {
          console.log(`‚è±Ô∏è Joueur ${socket.id} n'est pas revenu apr√®s 15s, retrait du joueur`);
          
          // Compter combien de joueurs sont en attente de reconnexion
          const waitingCount = Array.from(this.disconnectTimers.values()).length;
          console.log(`üìä ${waitingCount} joueur(s) en attente de reconnexion`);
          
          currentGame.removePlayer(socket.id);
          
          // Supprimer la partie si elle est vide
          if (currentGame.players.length === 0) {
            this.games.delete(gameId);
            console.log(`Partie supprim√©e: ${gameId}`);
          }
        } else {
          console.log(`‚úÖ Joueur ${socket.id} s'est d√©j√† reconnect√© avec un nouveau socket`);
        }
        
        this.disconnectTimers.delete(socket.id);
        this.socketToGame.delete(socket.id);
      }, 15000);
      
      this.disconnectTimers.set(socket.id, timer);
    } else {
      // Si la partie n'a pas encore d√©marr√©, retirer imm√©diatement
      game.removePlayer(socket.id);
      
      // Supprimer la partie si elle est vide
      if (game.players.length === 0) {
        this.games.delete(gameId);
        console.log(`Partie supprim√©e: ${gameId}`);
      }
      
      this.socketToGame.delete(socket.id);
    }
  }
}

================================================================================
File: websocket\models\classes\Aleatoire.js
Size: 5.16 kB
================================================================================

import Player from '../Player.js';

export default class Aleatoire extends Player {
  constructor(playerId, color, game) {
    super(playerId, color, game);
    this.className = 'aleatoire';
    this.currentAbility = null;
    this.selectRandomAbility();
  }

  selectRandomAbility() {
    const abilities = ['bombman', 'bombwoman', 'parieur', 'roulette', 'shuffle'];
    this.currentAbility = abilities[Math.floor(Math.random() * abilities.length)];
  }

  useAbility(x, y) {
    if (!this.canUseAbility()) {
      return { success: false, reason: 'not_charged' };
    }

    this.abilityCharges = 0;
    this.abilityUsedThisWave = true;
    let result = { success: false };

    switch (this.currentAbility) {
      case 'bombman':
        result = this.bombmanAbility(x, y);
        break;
      case 'bombwoman':
        result = this.bombwomanAbility(x, y);
        break;
      case 'parieur':
        result = this.parieurAbility(x, y);
        break;
      case 'roulette':
        result = this.rouletteAbility(x, y);
        break;
      case 'shuffle':
        result = this.shuffleAbility();
        break;
    }

    if (result.success) {
      this.selectRandomAbility();
    }

    return result;
  }

  bombmanAbility(x, y) {
    if (x < 0 || x >= 5 || y < 0 || y >= 5) {
      return { success: false, reason: 'out_of_bounds' };
    }

    const positions = [
      [x, y],
      [x - 1, y],
      [x + 1, y],
      [x, y - 1],
      [x, y + 1]
    ];

    positions.forEach(([px, py]) => {
      if (px >= 0 && px < 5 && py >= 0 && py < 5) {
        const cell = this.game.grid[px][py];
        cell.color = null;
        cell.hp = 0;
        cell.playerId = null;
      }
    });

    return { success: true };
  }

  bombwomanAbility(x, y) {
    if (x < 0 || x >= 5 || y < 0 || y >= 5) {
      return { success: false, reason: 'out_of_bounds' };
    }

    for (let i = 0; i < 5; i++) {
      this.game.grid[x][i].color = null;
      this.game.grid[x][i].hp = 0;
      this.game.grid[x][i].playerId = null;
    }

    return { success: true };
  }

  parieurAbility(x, y) {
    if (x < 0 || x >= 5 || y < 0 || y >= 5) {
      return { success: false, reason: 'out_of_bounds' };
    }

    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        const nx = x + dx;
        const ny = y + dy;
        if (nx >= 0 && nx < 5 && ny >= 0 && ny < 5) {
          this.game.grid[nx][ny].color = null;
          this.game.grid[nx][ny].hp = 0;
          this.game.grid[nx][ny].playerId = null;
        }
      }
    }

    const colors = this.game.players.map(p => p.color);
    for (let i = 0; i < 6; i++) {
      const rx = Math.floor(Math.random() * 5);
      const ry = Math.floor(Math.random() * 5);
      const randomColor = colors[Math.floor(Math.random() * colors.length)];
      
      this.game.grid[rx][ry].color = randomColor;
      this.game.grid[rx][ry].hp = 1;
      this.game.grid[rx][ry].playerId = this.playerId;
    }

    return { success: true };
  }

  rouletteAbility(x, y) {
    if (x < 0 || x >= 5) {
      return { success: false, reason: 'out_of_bounds' };
    }

    const availablePositions = [];
    for (let col = 0; col < 5; col++) {
      if (this.game.grid[x][col].color === null) {
        availablePositions.push(col);
      }
    }

    if (availablePositions.length < 2) {
      return { success: false, reason: 'not_enough_space' };
    }

    for (let i = 0; i < 2 && availablePositions.length > 0; i++) {
      const randomIndex = Math.floor(Math.random() * availablePositions.length);
      const col = availablePositions.splice(randomIndex, 1)[0];
      
      this.game.grid[x][col].color = this.color;
      this.game.grid[x][col].hp = 1;
      this.game.grid[x][col].playerId = this.playerId;
    }

    return { success: true };
  }

  shuffleAbility() {
    const blocks = [];
    
    for (let i = 0; i < 5; i++) {
      for (let j = 0; j < 5; j++) {
        if (this.game.grid[i][j].color !== null) {
          blocks.push({
            color: this.game.grid[i][j].color,
            hp: this.game.grid[i][j].hp,
            playerId: this.game.grid[i][j].playerId
          });
          this.game.grid[i][j].color = null;
          this.game.grid[i][j].hp = 0;
          this.game.grid[i][j].playerId = null;
        }
      }
    }

    for (let i = blocks.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [blocks[i], blocks[j]] = [blocks[j], blocks[i]];
    }

    let blockIndex = 0;
    for (let i = 0; i < 5 && blockIndex < blocks.length; i++) {
      for (let j = 0; j < 5 && blockIndex < blocks.length; j++) {
        if (this.game.grid[i][j].color === null) {
          this.game.grid[i][j].color = blocks[blockIndex].color;
          this.game.grid[i][j].hp = blocks[blockIndex].hp;
          this.game.grid[i][j].playerId = blocks[blockIndex].playerId;
          blockIndex++;
        }
      }
    }

    return { success: true };
  }
}


================================================================================
File: websocket\models\classes\Bombman.js
Size: 913 B
================================================================================

import Player from '../Player.js';

export default class Bombman extends Player {
  constructor(playerId, color, game) {
    super(playerId, color, game);
    this.className = 'bombman';
  }

  useAbility(x, y) {
    if (!this.canUseAbility()) {
      return { success: false, reason: 'not_charged' };
    }

    if (x < 0 || x >= 5 || y < 0 || y >= 5) {
      return { success: false, reason: 'out_of_bounds' };
    }

    const directions = [
      [x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1], [x, y]
    ];

    directions.forEach(([nx, ny]) => {
      if (nx >= 0 && nx < 5 && ny >= 0 && ny < 5) {
        const cell = this.game.grid[nx][ny];
        cell.color = null;
        cell.playerId = null;
        cell.hp = 0;
        cell.waveNumber = null;
      }
    });

    this.abilityCharges = 0;
    this.abilityUsedThisWave = true;
    return { success: true };
  }
}

================================================================================
File: websocket\models\classes\Bombwoman.js
Size: 2.06 kB
================================================================================

// ============================================================================
// models/classes/Bombwoman.js
// Classe Bombwoman - D√©truit ligne ou colonne, ne peut pas poser dedans 6s
// ============================================================================

import Player from '../Player.js';

export default class Bombwoman extends Player {
  constructor(playerId, color, game) {
    super(playerId, color, game);
    this.className = 'bombwoman';
    this.abilityCooldown = 10000; // 10s
    this.blockedRow = null;
    this.blockedCol = null;
  }

  useAbility(x, y) {
    if (!this.canUseAbility()) {
      return { success: false, reason: 'not_charged' };
    }

    if (x < 0 || x >= 5 || y < 0 || y >= 5) {
      return { success: false, reason: 'out_of_bounds' };
    }

    const destroyRow = Math.random() < 0.5;

    if (destroyRow) {
      for (let col = 0; col < 5; col++) {
        const cell = this.game.grid[x][col];
        cell.color = null;
        cell.playerId = null;
        cell.hp = 0;
        cell.waveNumber = null;
      }
      this.blockedRow = x;
      this.blockedCol = null;
    } else {
      for (let row = 0; row < 5; row++) {
        const cell = this.game.grid[row][y];
        cell.color = null;
        cell.playerId = null;
        cell.hp = 0;
        cell.waveNumber = null;
      }
      this.blockedRow = null;
      this.blockedCol = y;
    }

    const timer = setTimeout(() => {
      this.blockedRow = null;
      this.blockedCol = null;
    }, 6000);
    this.timers.push(timer);

    this.abilityCharges = 0;
    this.abilityUsedThisWave = true;
    return { success: true };
  }

  placeBlock(x, y) {
    // V√©rifier si la position est bloqu√©e
    if (this.blockedRow !== null && x === this.blockedRow) {
      return { success: false, reason: 'blocked' };
    }
    if (this.blockedCol !== null && y === this.blockedCol) {
      return { success: false, reason: 'blocked' };
    }

    return super.placeBlock(x, y);
  }
}

================================================================================
File: websocket\models\classes\Fast.js
Size: 879 B
================================================================================

import Player from '../Player.js';

export default class Fast extends Player {
  constructor(playerId, color, game) {
    super(playerId, color, game);
    this.className = 'fast';
  }

  placeBlock(x, y) {
    if (!this.canPlace()) {
      return { success: false, reason: 'not_enough_ap' };
    }

    if (x < 0 || x >= 5 || y < 0 || y >= 5) {
      return { success: false, reason: 'out_of_bounds' };
    }

    const cell = this.game.grid[x][y];
    
    if (cell.color !== null && cell.hp > 0) {
      return { success: false, reason: 'cell_occupied' };
    }

    cell.color = this.color;
    cell.hp = 0;
    cell.playerId = this.playerId;
    cell.waveNumber = this.game.waveNumber;
    
    this.actionPoints -= 1;
    
    return { success: true };
  }

  useAbility(x, y) {
    return { success: false, reason: 'no_ability' };
  }
}

================================================================================
File: websocket\models\classes\index.js
Size: 645 B
================================================================================

// ============================================================================
// models/classes/index.js
// Export de toutes les classes
// ============================================================================

export { default as Bombman } from './Bombman.js';
export { default as Parieur } from './Parieur.js';
export { default as Bombwoman } from './Bombwoman.js';
export { default as Fast } from './Fast.js';
export { default as Solide } from './Solide.js';
export { default as Roulette } from './Roulette.js';
export { default as Shuffle } from './Shuffle.js';
export { default as Aleatoire } from './Aleatoire.js';    

================================================================================
File: websocket\models\classes\Parieur.js
Size: 1.95 kB
================================================================================

// ============================================================================
// models/classes/Parieur.js
// Classe Parieur - D√©truit 3x3 et remplace par 6 blocs al√©atoires (2 √† lui)
// ============================================================================

import Player from '../Player.js';

export default class Parieur extends Player {
  constructor(playerId, color, game) {
    super(playerId, color, game);
    this.className = 'parieur';
  }

  useAbility(x, y) {
    if (!this.canUseAbility()) {
      return { success: false, reason: 'not_charged' };
    }

    if (x < 0 || x >= 5 || y < 0 || y >= 5) {
      return { success: false, reason: 'out_of_bounds' };
    }

    const cells = [];
    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        const nx = x + dx;
        const ny = y + dy;
        if (nx >= 0 && nx < 5 && ny >= 0 && ny < 5) {
          cells.push([nx, ny]);
        }
      }
    }

    cells.forEach(([nx, ny]) => {
      const cell = this.game.grid[nx][ny];
      cell.color = null;
      cell.playerId = null;
      cell.hp = 0;
      cell.waveNumber = null;
    });

    const shuffled = cells.sort(() => Math.random() - 0.5);
    
    const colors = this.game.players.map(p => p.color);
    const blocksToPlace = [
      this.color, this.color,
      ...Array(4).fill(null).map(() => colors[Math.floor(Math.random() * colors.length)])
    ];

    blocksToPlace.forEach((color, i) => {
      if (i < shuffled.length) {
        const [nx, ny] = shuffled[i];
        const cell = this.game.grid[nx][ny];
        cell.color = color;
        cell.hp = 1;
        cell.playerId = this.game.players.find(p => p.color === color)?.playerId || null;
        cell.waveNumber = this.game.waveNumber;
      }
    });

    this.abilityCharges = 0;
    this.abilityUsedThisWave = true;
    return { success: true };
  }
}

================================================================================
File: websocket\models\classes\Roulette.js
Size: 1.6 kB
================================================================================

// ============================================================================
// models/classes/Roulette.js
// Classe Roulette - Pose 2 blocs al√©atoires sur une m√™me ligne
// ============================================================================

import Player from "../Player.js";

export default class Roulette extends Player {
  constructor(playerId, color, game) {
    super(playerId, color, game);
    this.className = "roulette";
  }

  useAbility(x, y) {
    if (!this.canUseAbility()) {
      return { success: false, reason: "not_charged" };
    }

    if (x < 0 || x >= 5) {
      return { success: false, reason: "out_of_bounds" };
    }

    const emptyCells = [];
    for (let col = 0; col < 5; col++) {
      if (this.game.grid[x][col].color === null) {
        emptyCells.push(col);
      }
    }

    if (emptyCells.length < 2) {
      return { success: false, reason: "not_enough_empty_cells" };
    }

    const shuffled = emptyCells.sort(() => Math.random() - 0.5);
    const [col1, col2] = shuffled.slice(0, 2);

    this.game.grid[x][col1].color = this.color;
    this.game.grid[x][col1].hp = 1;
    this.game.grid[x][col1].playerId = this.playerId;
    this.game.grid[x][col1].waveNumber = this.game.waveNumber;

    this.game.grid[x][col2].color = this.color;
    this.game.grid[x][col2].hp = 1;
    this.game.grid[x][col2].playerId = this.playerId;
    this.game.grid[x][col2].waveNumber = this.game.waveNumber;

    this.abilityCharges = 0;
    this.abilityUsedThisWave = true;
    return { success: true };
  }
}


================================================================================
File: websocket\models\classes\Shuffle.js
Size: 2.06 kB
================================================================================

// ============================================================================
// models/classes/Shuffle.js
// Classe Shuffle - M√©lange al√©atoirement toute la grille
// ============================================================================

import Player from '../Player.js';

export default class Shuffle extends Player {
  constructor(playerId, color, game) {
    super(playerId, color, game);
    this.className = 'shuffle';
  }

  useAbility(x, y) {
    if (!this.canUseAbility()) {
      return { success: false, reason: 'not_charged' };
    }

    const blocks = [];
    for (let row = 0; row < 5; row++) {
      for (let col = 0; col < 5; col++) {
        const cell = this.game.grid[row][col];
        if (cell.color !== null) {
          blocks.push({
            color: cell.color,
            hp: cell.hp,
            playerId: cell.playerId,
            waveNumber: cell.waveNumber
          });
        }
      }
    }

    for (let row = 0; row < 5; row++) {
      for (let col = 0; col < 5; col++) {
        this.game.grid[row][col].color = null;
        this.game.grid[row][col].hp = 0;
        this.game.grid[row][col].playerId = null;
        this.game.grid[row][col].waveNumber = null;
      }
    }

    const shuffled = blocks.sort(() => Math.random() - 0.5);

    const positions = [];
    for (let row = 0; row < 5; row++) {
      for (let col = 0; col < 5; col++) {
        positions.push([row, col]);
      }
    }
    const shuffledPositions = positions.sort(() => Math.random() - 0.5);

    shuffled.forEach((block, i) => {
      if (i < shuffledPositions.length) {
        const [row, col] = shuffledPositions[i];
        this.game.grid[row][col].color = block.color;
        this.game.grid[row][col].hp = block.hp;
        this.game.grid[row][col].playerId = block.playerId;
        this.game.grid[row][col].waveNumber = block.waveNumber;
      }
    });

    this.abilityCharges = 0;
    this.abilityUsedThisWave = true;
    return { success: true };
  }
}

================================================================================
File: websocket\models\classes\Solide.js
Size: 1.18 kB
================================================================================

// ============================================================================
// models/classes/Solide.js
// Classe Solide - Blocs avec 2 PV, cooldown multipli√© par 2
// ============================================================================

import Player from '../Player.js';

export default class Solide extends Player {
  constructor(playerId, color, game) {
    super(playerId, color, game);
    this.className = 'solide';
  }

  placeBlock(x, y) {
    if (!this.canPlace()) {
      return { success: false, reason: 'not_enough_ap' };
    }

    if (x < 0 || x >= 5 || y < 0 || y >= 5) {
      return { success: false, reason: 'out_of_bounds' };
    }

    const cell = this.game.grid[x][y];
    if (cell.color !== null) {
      return { success: false, reason: 'cell_occupied' };
    }

    cell.color = this.color;
    cell.hp = 2; // Blocs avec 2 PV
    cell.playerId = this.playerId;
    cell.waveNumber = this.game.waveNumber;
    this.actionPoints -= 1;
    
    return { success: true };
  }

  useAbility(x, y) {
    // Solide n'a pas de pouvoir sp√©cial unique
    return { success: false, reason: 'no_ability' };
  }
}

================================================================================
File: websocket\models\classes\Voyageur.js
Size: 2.17 kB
================================================================================

// ============================================================================
// models/classes/Voyageur.js
// Classe Voyageur - Arr√™te le temps pour les autres pendant 5s
// ============================================================================

import Player from '../Player.js';

export default class Voyageur extends Player {
  constructor(playerId, color, game) {
    super(playerId, color, game);
    this.className = 'voyageur';
    this.abilityCooldown = 15000; // 15s
    this.timeStopActive = false;
  }

  useAbility(x, y) {
    if (!this.canUseAbility()) {
      return { success: false, reason: 'cooldown' };
    }

    // Activer l'arr√™t du temps
    this.timeStopActive = true;

    // Sauvegarder les cooldowns actuels des autres joueurs
    const otherPlayers = this.game.players.filter(p => p.playerId !== this.playerId);
    const savedCooldowns = otherPlayers.map(p => ({
      player: p,
      lastPlace: p.lastPlace,
      lastDestroy: p.lastDestroy,
      lastAbility: p.lastAbility
    }));

    // Geler les actions des autres joueurs
    otherPlayers.forEach(p => {
      p.frozen = true;
    });

    // Notifier tous les joueurs
    this.game.io.to(`game_${this.game.gameId}`).emit('time_stop_start', {
      voyageurId: this.playerId,
      duration: 5000
    });

    // D√©bloquer apr√®s 5s
    const timer = setTimeout(() => {
      this.timeStopActive = false;
      
      // Restaurer l'√©tat des autres joueurs et ajuster leurs cooldowns
      const timeElapsed = 5000;
      savedCooldowns.forEach(({ player, lastPlace, lastDestroy, lastAbility }) => {
        player.frozen = false;
        // Ajuster les timestamps pour compenser le temps gel√©
        player.lastPlace = lastPlace + timeElapsed;
        player.lastDestroy = lastDestroy + timeElapsed;
        player.lastAbility = lastAbility + timeElapsed;
      });

      this.game.io.to(`game_${this.game.gameId}`).emit('time_stop_end', {
        voyageurId: this.playerId
      });
    }, 5000);
    this.timers.push(timer);

    this.lastAbility = Date.now();
    return { success: true };
  }
}

================================================================================
File: websocket\models\Game.js
Size: 9.99 kB
================================================================================

// ============================================================================
// models/Game.js
// Logique principale d'une partie
// ============================================================================

import Player from './Player.js';
import * as Classes from './classes/index.js';

export default class Game {
  constructor(gameId, io) {
    this.gameId = gameId;
    this.io = io;
    this.players = [];
    this.grid = this.generateGrid();
    this.started = false;
    this.waveNumber = 0;
    this.waveTimer = null;
    this.WAVE_DURATION = 10000;
    this.colors = ['#e74c3c', '#3498db', '#16a34a', '#f59e0b'];
    this.availableColors = [...this.colors];
    this.playerActions = new Map();
  }

  generateGrid() {
    const grid = [];
    for (let i = 0; i < 5; i++) {
      const row = [];
      for (let j = 0; j < 5; j++) {
        row.push({ color: null, hp: 0, playerId: null, waveNumber: null });
      }
      grid.push(row);
    }
    return grid;
  }

  addPlayer(socket, playerClass, pseudo = '') {
    if (this.players.length >= 4) return false;
    if (this.players.some(p => p.className === playerClass)) return false;

    const color = this.availableColors.shift();
    const PlayerClass = this.getPlayerClass(playerClass);
    
    if (!pseudo) {
      pseudo = this.generateRandomPseudo();
    }
    
    const player = new PlayerClass(socket.id, color, this, pseudo);
    
    this.players.push(player);
    console.log(`Joueur ${pseudo} (${socket.id}) a rejoint la partie ${this.gameId} avec la classe ${playerClass}`);
    
    return true;
  }

  generateRandomPseudo() {
    const pseudos = [
      'Jean-Passe', 'Marie-Olette', 'Pierre-Fect', 'Sophie-Stiqu√©',
      'Paul-Ochon', 'Julie-Ette', 'Marc-Hand', 'Anne-Anas',
      'Luc-Arne', 'Emma-Nuelle', 'Tom-Ate', 'Clara-Vate',
      'Hugo-Lant', 'L√©a-Zard', 'Max-Imum', 'Chlo√©-Ture',
      'Alex-T√©rieur', 'Sarah-Phin', 'Lucas-Cade', 'Zo√©-Nith',
      'Th√©o-Rie', 'In√®s-P√©r√©', 'Nathan-Tique', 'Manon-Yme',
      'Arthur-Mite', 'Camille-√âon', 'Louis-Tique', 'Jade-Ite',
      'Gabriel-Ium', 'Lily-Ac√©', 'Rapha√´l-Ectrique', 'Nina-Teur'
    ];
    return pseudos[Math.floor(Math.random() * pseudos.length)];
  }

  getPlayerClass(className) {
    const classMap = {
      'bombman': Classes.Bombman,
      'parieur': Classes.Parieur,
      'bombwoman': Classes.Bombwoman,
      'fast': Classes.Fast,
      'solide': Classes.Solide,
      'roulette': Classes.Roulette,
      'shuffle': Classes.Shuffle,
      'aleatoire': Classes.Aleatoire
    };
    return classMap[className.toLowerCase()] || Player;
  }

  // Retirer un joueur
  removePlayer(socketId) {
    const index = this.players.findIndex(p => p.playerId === socketId);
    if (index !== -1) {
      const player = this.players[index];
      this.availableColors.push(player.color);
      this.players.splice(index, 1);
      
      this.io.to(`game_${this.gameId}`).emit('player_left', {
        playerId: socketId,
        remainingPlayers: this.players.length
      });

      // Arr√™ter la partie si moins de 2 joueurs
      if (this.players.length < 2 && this.started) {
        this.endGame('not_enough_players');
      }
    }
  }

  // Obtenir un joueur
  getPlayer(socketId) {
    return this.players.find(p => p.playerId === socketId);
  }

  // D√©marrer la partie
  startGame() {
    this.started = true;
    this.waveNumber = 1;
    console.log(`Partie ${this.gameId} d√©marr√©e avec ${this.players.length} joueurs`);
    
    this.io.to(`game_${this.gameId}`).emit('game_started', {
      message: 'La partie commence !',
      players: this.players.map(p => ({
        id: p.playerId,
        color: p.color,
        class: p.className
      }))
    });

    this.startWave();
  }

  startWave() {
    this.players.forEach(player => {
      player.resetWave();
    });

    this.io.to(`game_${this.gameId}`).emit('wave_start', {
      waveNumber: this.waveNumber,
      duration: this.WAVE_DURATION
    });

    this.waveTimer = setTimeout(() => {
      this.endWave();
    }, this.WAVE_DURATION);
  }

  // Terminer une vague
  endWave() {
    if (this.waveTimer) {
      clearTimeout(this.waveTimer);
      this.waveTimer = null;
    }

    this.io.to(`game_${this.gameId}`).emit('wave_end', {
      waveNumber: this.waveNumber
    });

    // V√©rifier la victoire
    const winner = this.checkWin();
    if (winner) {
      this.endGame('victory', winner);
      return;
    }

    // Passer √† la vague suivante
    this.waveNumber++;
    setTimeout(() => {
      if (this.started) {
        this.startWave();
      }
    }, 2000);
  }

  placeBlock(playerId, x, y) {
    const player = this.getPlayer(playerId);
    if (!player || !this.started) return;

    const result = player.placeBlock(x, y);
    if (result.success) {
      this.broadcastGameState();
      this.checkWaveComplete();
    }
  }

  destroyBlock(playerId, x, y) {
    const player = this.getPlayer(playerId);
    if (!player || !this.started) return;

    const result = player.destroyBlock(x, y);
    if (result.success) {
      this.broadcastGameState();
      this.checkWaveComplete();
    }
  }

  useAbility(playerId, x, y) {
    const player = this.getPlayer(playerId);
    if (!player || !this.started) return;

    const result = player.useAbility(x, y);
    if (result.success) {
      this.broadcastGameState();
      this.checkWaveComplete();
    }
  }

  checkWaveComplete() {
    const allPlayersFinished = this.players.every(p => p.actionPoints === 0);
    
    if (allPlayersFinished) {
      if (this.waveTimer) {
        clearTimeout(this.waveTimer);
      }
      this.endWave();
    }
  }

  skipTurn(playerId) {
    const player = this.getPlayer(playerId);
    if (!player || !this.started) return;

    player.hasSkipped = true;
    player.actionPoints = 0;
    this.broadcastGameState();
    this.checkWaveComplete();
  }

  // V√©rifier la victoire
  checkWin() {
    const winLength = 3;
    const size = 5;

    // V√©rifier horizontalement
    for (let row = 0; row < size; row++) {
      for (let col = 0; col <= size - winLength; col++) {
        const first = this.grid[row][col];
        if (first.color && first.color !== null) {
          let matches = true;
          for (let k = 1; k < winLength; k++) {
            if (this.grid[row][col + k].color !== first.color) {
              matches = false;
              break;
            }
          }
          if (matches) {
            return this.players.find(p => p.color === first.color);
          }
        }
      }
    }

    // V√©rifier verticalement
    for (let col = 0; col < size; col++) {
      for (let row = 0; row <= size - winLength; row++) {
        const first = this.grid[row][col];
        if (first.color && first.color !== null) {
          let matches = true;
          for (let k = 1; k < winLength; k++) {
            if (this.grid[row + k][col].color !== first.color) {
              matches = false;
              break;
            }
          }
          if (matches) {
            return this.players.find(p => p.color === first.color);
          }
        }
      }
    }

    // V√©rifier diagonale ‚Üò
    for (let row = 0; row <= size - winLength; row++) {
      for (let col = 0; col <= size - winLength; col++) {
        const first = this.grid[row][col];
        if (first.color && first.color !== null) {
          let matches = true;
          for (let k = 1; k < winLength; k++) {
            if (this.grid[row + k][col + k].color !== first.color) {
              matches = false;
              break;
            }
          }
          if (matches) {
            return this.players.find(p => p.color === first.color);
          }
        }
      }
    }

    // V√©rifier diagonale ‚Üó
    for (let row = winLength - 1; row < size; row++) {
      for (let col = 0; col <= size - winLength; col++) {
        const first = this.grid[row][col];
        if (first.color && first.color !== null) {
          let matches = true;
          for (let k = 1; k < winLength; k++) {
            if (this.grid[row - k][col + k].color !== first.color) {
              matches = false;
              break;
            }
          }
          if (matches) {
            return this.players.find(p => p.color === first.color);
          }
        }
      }
    }

    return null;
  }

  // Terminer la partie
  endGame(reason, winner = null) {
    this.started = false;
    
    if (this.waveTimer) {
      clearTimeout(this.waveTimer);
      this.waveTimer = null;
    }

    // Nettoyer les timers des joueurs
    this.players.forEach(p => p.cleanup());

    this.io.to(`game_${this.gameId}`).emit('game_over', {
      reason,
      winner: winner ? {
        id: winner.playerId,
        color: winner.color,
        class: winner.className
      } : null
    });

    console.log(`Partie ${this.gameId} termin√©e. Raison: ${reason}`);
  }

  // Diffuser l'√©tat du jeu
  broadcastGameState() {
    this.io.to(`game_${this.gameId}`).emit('game_state_update', this.getGameState());
  }

  getGameState() {
    return {
      gameId: this.gameId,
      waveNumber: this.waveNumber,
      grid: this.grid,
      players: this.players.map(p => ({
        id: p.playerId,
        color: p.color,
        class: p.className,
        pseudo: p.pseudo,
        actionPoints: p.actionPoints,
        hasSkipped: p.hasSkipped,
        canPlace: p.canPlace(),
        canDestroy: p.canDestroy(),
        canUseAbility: p.canUseAbility(),
        abilityCharges: p.abilityCharges,
        currentAbility: p.currentAbility || null
      })),
      started: this.started
    };
  }
}

================================================================================
File: websocket\models\Player.js
Size: 2.95 kB
================================================================================

// ============================================================================
// models/Player.js
// Classe de base pour tous les joueurs
// ============================================================================

export default class Player {
  constructor(playerId, color, game, pseudo = '') {
    this.playerId = playerId;
    this.color = color;
    this.game = game;
    this.className = 'base';
    this.pseudo = pseudo;
    
    this.actionPoints = 0;
    this.abilityCharges = 0;
    this.abilityMaxCharges = 3;
    this.abilityUsedThisWave = false;
    this.hasSkipped = false;
    
    this.timers = [];
  }

  resetWave() {
    const pointsToAdd = this.className === 'fast' ? 2 : 1;
    this.actionPoints += pointsToAdd;
    this.abilityCharges = Math.min(this.abilityCharges + 1, this.abilityMaxCharges);
    this.abilityUsedThisWave = false;
    this.hasSkipped = false;
  }

  canPlace() {
    return this.actionPoints >= 1 && !this.hasSkipped;
  }

  canDestroy() {
    return this.actionPoints >= 1 && !this.hasSkipped;
  }

  canUseAbility() {
    return this.abilityCharges >= this.abilityMaxCharges && !this.abilityUsedThisWave;
  }

  skipTurn() {
    return { success: true };
  }

  placeBlock(x, y) {
    if (!this.canPlace()) {
      return { success: false, reason: 'not_enough_ap' };
    }

    if (x < 0 || x >= 5 || y < 0 || y >= 5) {
      return { success: false, reason: 'out_of_bounds' };
    }

    const cell = this.game.grid[x][y];
    if (cell.color !== null) {
      return { success: false, reason: 'cell_occupied' };
    }

    cell.color = this.color;
    cell.hp = 1;
    cell.playerId = this.playerId;
    cell.waveNumber = this.game.waveNumber;
    
    this.actionPoints -= 1;
    
    return { success: true };
  }

  destroyBlock(x, y) {
    if (!this.canDestroy()) {
      return { success: false, reason: 'not_enough_ap' };
    }

    if (x < 0 || x >= 5 || y < 0 || y >= 5) {
      return { success: false, reason: 'out_of_bounds' };
    }

    const cell = this.game.grid[x][y];
    if (cell.color === null) {
      return { success: false, reason: 'cell_empty' };
    }

    if (cell.waveNumber === this.game.waveNumber) {
      return { success: false, reason: 'protected_block' };
    }

    cell.hp--;
    if (cell.hp <= 0) {
      cell.color = null;
      cell.playerId = null;
      cell.hp = 0;
      cell.waveNumber = null;
    }
    
    this.actionPoints -= 1;
    
    return { success: true };
  }

  useAbility(x, y) {
    if (!this.canUseAbility()) {
      return { success: false, reason: 'not_charged' };
    }
    
    this.abilityCharges = 0;
    this.abilityUsedThisWave = true;
    return { success: false, reason: 'no_ability' };
  }

  // Nettoyer les timers
  cleanup() {
    this.timers.forEach(timer => clearTimeout(timer));
    this.timers = [];
  }
}

================================================================================
File: websocket\server.js
Size: 3.2 kB
================================================================================

// ============================================================================
// server.js
// Point d'entr√©e du serveur
// ============================================================================

import express from 'express';
import { createServer } from 'http';
import { Server } from 'socket.io';
import cors from 'cors';
import path from 'path';
import { fileURLToPath } from 'url';
import GameManager from './gameManager.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
app.use(cors());
app.use(express.json());

// Servir les fichiers statiques du frontend
app.use(express.static(path.join(__dirname, '../front')));

const server = createServer(app);
const io = new Server(server, {
  cors: {
    origin: true, // Autorise toutes les origines
    methods: ["GET", "POST"],
    credentials: true,
    allowedHeaders: ["Content-Type", "Authorization"]
  },
  allowEIO3: true, // Pour la compatibilit√© avec les anciennes versions de Socket.IO
  transports: ['websocket', 'polling'] // Activer plusieurs m√©thodes de transport
});

// Middleware pour g√©rer les en-t√™tes CORS manuellement
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');
  next();
});

const PORT = process.env.PORT || 8080;

// Instance unique du gestionnaire de parties
const gameManager = new GameManager(io);

// Gestion des connexions socket
io.on('connection', (socket) => {
  console.log(`Joueur connect√©: ${socket.id}`);

  socket.on('join_game', (data) => {
    const { gameId, playerClass, pseudo } = data;
    gameManager.handleJoinGame(socket, gameId, playerClass, pseudo);
  });

  // Action de placement de bloc
  socket.on('place_block', (data) => {
    const { x, y } = data;
    gameManager.handlePlaceBlock(socket, x, y);
  });

  socket.on('start_game', () => {
    gameManager.handleStartGame(socket);
  });

  // Action de destruction de bloc
  socket.on('destroy_block', (data) => {
    const { x, y } = data;
    gameManager.handleDestroyBlock(socket, x, y);
  });

  // Utilisation du pouvoir sp√©cial
  socket.on('use_ability', (data) => {
    const { x, y } = data;
    gameManager.handleUseAbility(socket, x, y);
  });

  socket.on('skip_turn', () => {
    gameManager.handleSkipTurn(socket);
  });

  // D√©connexion
  socket.on('disconnect', () => {
    console.log(`Joueur d√©connect√©: ${socket.id}`);
    gameManager.handleDisconnect(socket);
  });
});

server.listen(PORT, '0.0.0.0', () => {
  console.log(`\n========================================`);
  console.log(`Serveur lanc√© sur le port ${PORT}`);
  console.log(`\nAcc√®s local: http://localhost:${PORT}`);
  console.log(`\nPour acc√©der depuis un autre appareil:`);
  console.log(`1. Trouvez votre adresse IP locale avec: hostname -I`);
  console.log(`2. Utilisez: http://[VOTRE_IP]:${PORT}`);
  console.log(`========================================\n`);
});
